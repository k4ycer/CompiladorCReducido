/*
 * Ejemplo con una gramatica recursiva por la izquierda y
 * otra que elimina dicha recursividad izquierda.
 */

global
{
    analysis    LL1;
    nonterminal Program, Deflist, A, Def, Vardef, Idlistdef, Idinit, Idlistdefcont, Fundef, Fundec, Paramlist, Paramlistcont, Stmtlist, B, Stmt, Stmtassign, Stmtincr, Stmtdecr, Funcall, Exprlist, Exprlistcont, Stmtif, Elseiflist, C, Else, Stmtbreak, Stmtreturn, Stmtempty, Expr, Expror, D, Exprand, E, Exprcomp, F, Opcomp, Exprrel, G, Oprel, Expradd, H, Opadd, Exprmul, I, Opmul, Exprunary, Opunary, Exprprimary, Lit, Type, Idinitp, Defp, Fundefp, Stmtfor, Exprprimaryp, Stmtp, Stmtwhile;
    terminal    id, elseif, if, else, for, break, return, litint, litdouble, int, double, plusplus, minusminus, barbar, andand, equalsequals, lessthanequals, greaterthanequals, exclamationequals, plus, minus, asterisk, slash, percent, exclamation, equals, while, openparen, closeparen, comma, semicolon, openbrace, closebrace, greaterthan, lessthan;
}

/*
 * Gramatica C Reducido
 */
grammar c_reducido
{
Program := Deflist ;
Deflist := A ;
A := Def A | ;
Def := Type id Defp ;
Defp := Vardef | Fundef ;
Vardef := Idlistdef semicolon ;
Idlistdef := Idinitp Idlistdefcont ;
Idinitp := equals Lit | ;
Idlistdefcont := comma id Idinitp Idlistdefcont | ;
Fundef := Fundec Fundefp ;
Fundefp := semicolon | openbrace Stmtlist closebrace ;
Fundec := openparen Paramlist closeparen ;
Paramlist := Type id Paramlistcont | ;
Paramlistcont := comma Type id Paramlistcont | ;
Stmtlist := B ;
B := Stmt B | ;
Stmt := Type id Idlistdef semicolon | id Stmtp | Stmtif | Stmtfor | Stmtbreak | Stmtreturn | Stmtempty | Stmtwhile ;
Stmtp := Stmtassign | Funcall | Stmtincr | Stmtdecr ;
Stmtassign := equals Expr semicolon ;
Stmtincr := plusplus semicolon ;
Stmtdecr := minusminus semicolon ;
Funcall := openparen Exprlist closeparen semicolon ;
Exprlist := Expr Exprlistcont | ;
Exprlistcont := comma Expr Exprlistcont | ;
Stmtif := if openparen Expr closeparen openbrace Stmtlist closebrace Elseiflist Else ;
Elseiflist := C ;
C := elseif openparen Expr closeparen openbrace Stmtlist closebrace C | ;
Else := else openbrace Stmtlist closebrace | ;
Stmtfor	:= for openparen Expr semicolon Expr semicolon Expr closeparen openbrace Stmtlist closebrace ;
Stmtwhile := while openparen Expr closeparen openbrace Stmtlist closebrace ;
Stmtbreak := break semicolon ;
Stmtreturn := return Expr semicolon ;
Stmtempty := semicolon ;
Expr := Expror ;
Expror := Exprand D ;
D := barbar Exprand D | ;
Exprand := Exprcomp E ;
E := andand Exprcomp E | ;
Exprcomp := Exprrel F ;
F := Opcomp Exprrel F | ;
Opcomp := equalsequals | exclamationequals ;
Exprrel := Expradd G ;
G := Oprel Expradd G | ;
Oprel := lessthan | lessthanequals | greaterthan | greaterthanequals ;
Expradd := Exprmul H ;
H := Opadd Exprmul H | ;
Opadd := plus | minus ;
Exprmul := Exprunary I ;
I := Opmul Exprunary I | ;
Opmul := asterisk | slash | percent ;
Exprunary := Opunary Exprunary | Exprprimary ;
Opunary := plus | minus | exclamation ;
Exprprimary := id Exprprimaryp | Lit | openparen Expr closeparen ;
Exprprimaryp := openparen Exprlist closeparen | ;
Lit := litint | litdouble ;
Type := int | double ;
}
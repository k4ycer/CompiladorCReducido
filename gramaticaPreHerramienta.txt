/*
 * Ejemplo con una gramatica recursiva por la izquierda y
 * otra que elimina dicha recursividad izquierda.
 */

global
{
    analysis    LL1;
    nonterminal Program, Deflist, A, Def, Vardef, Idlistdef, Idinit, Idlistdefcont, Fundef, Fundec, Paramlist, Paramlistcont, Stmtlist, B, Stmt, Stmtassign, Stmtincr, Stmtdecr, Stmtfuncall, Funcall, Exprlist, Exprlistcont, Stmtif, Elseiflist, C, Else, Stmtloop, Stmtbreak, Stmtreturn, Stmtempty, Expr, Expror, D, Exprand, E, Exprcomp, F, Opcomp, Exprrel, G, Oprel, Expradd, H, Opadd, Exprmul, I, Opmul, Exprunary, Opunary, Exprprimary, Lit, Type, Idinitp, Defp, Fundefp;
    terminal    id, elseif, if, else, loop, break, return, litint, litdouble, int, double, plusplus, minusminus, barbar, andand, equalsequals, lessthanequals, greaterthanequals, exclamationequals, plus, minus, asterisk, slash, percent, exclamation, equals;
}

/*
 * Gramatica C Reducido
 */
grammar c_reducido
{
Program := Deflist ;
Deflist := A ;
A := Def A | ;
Def := Type Defp ;
Defp := Vardef | Fundef ;
Vardef := Idlistdef ';' ;
Idlistdef := Idinit Idlistdefcont ;
Idinit := id Idinitp ;
Idinitp := equals Lit | ;
Idlistdefcont := ',' Idinit Idlistdefcont | ;
Fundef := Fundec Fundefp ;
Fundefp := ';' | '{' Stmtlist '}' ;
Fundec := id '(' Paramlist ')' ;
Paramlist := Type id Paramlistcont | ;
Paramlistcont := ',' Type id Paramlistcont | ;
Stmtlist := B ;
B := Stmt B | ;
Stmt := Type Idlistdef ';' | Stmtassign | Stmtincr | Stmtdecr | Stmtfuncall | Stmtif | Stmtloop | Stmtbreak | Stmtreturn | Stmtempty ;
Stmtassign := id '=' Expr ';' ;
Stmtincr := id plusplus ';' ;
Stmtdecr := id minusminus ';' ;
Stmtfuncall := Funcall ';' ;
Funcall := id '(' Exprlist ')' ;
Exprlist := Expr Exprlistcont | ;
Exprlistcont := ',' Expr Exprlistcont | ;
Stmtif := if '(' Expr ')' '{' Stmtlist '}' Elseiflist Else ;
Elseiflist := C ;
C := elseif '(' Expr ')' '{' Stmtlist '}' C | ;
Else := else '{' Stmtlist '}' | ;
Stmtloop := loop '{' Stmtlist '}' ;
Stmtbreak := break ';' ;
Stmtreturn := return Expr ';' ;
Stmtempty := ';' ;
Expr := Expror ;
Expror := Exprand D ;
D := barbar Exprand D | ;
Exprand := Exprcomp E ;
E := andand Exprcomp E | ;
Exprcomp := Exprrel F ;
F := Opcomp Exprrel F | ;
Opcomp := equalsequals | exclamationequals ;
Exprrel := Expradd G ;
G := Oprel Expradd G | ;
Oprel := '<' | lessthanequals | '>' | greaterthanequals ;
Expradd := Exprmul H ;
H := Opadd Exprmul H | ;
Opadd := plus | minus ;
Exprmul := Exprunary I ;
I := Opmul Exprunary I | ;
Opmul := asterisk | slash | percent ;
Exprunary := Opunary Exprunary | Exprprimary ;
Opunary := plus | minus | exclamation ;
Exprprimary := id | id '(' Exprlist ')' | Lit | '(' Expr ')' ;
Lit := litint | litdouble ;
Type := int | double ;
}

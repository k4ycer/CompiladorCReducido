/*
 * Ejemplo con una gramatica recursiva por la izquierda y
 * otra que elimina dicha recursividad izquierda.
 */

global
{
    analysis    LL1;
    nonterminal Program, Deflist, A, Def, Vardef, Idlistdef, Idinit, Idlistdefcont, Fundef, Paramlist, Paramlistcont, Stmtlist, B, Stmt, Stmtassign, Stmtincr, Stmtdecr, Funcall, Exprlist, Exprlistcont, Stmtif, C, Stmtbreak, Stmtreturn, Stmtempty, Expr, Expror, Exprand, E, Exprcomp, F, Opcomp, Exprrel, G, Oprel, Expradd, H, Opadd, Exprmul, I, Opmul, Exprunary, Opunary, Exprprimary, Lit, Type, Idinitp, Defp, Fundefp, Stmtfor, Exprprimaryp, Stmtp, Stmtwhile, Varinit, Vardefcont, Varinitp, Stmtall, Flowcontrol, Stmtfuncall, Exprorp;
    terminal    identifier, krtIfKeyword, krtElseKeyword, krtForKeyword, krtBreakKeyword, krtReturnKeyword, krtIntegerLiteral, krtDoubleLiteral, krtIntKeyword, krtDoubleKeyword, krtPlusPlusToken, krtMinusMinusToken, krtBarBarToken, krtAmpersandAmpersandToken, krtEqualsEqualsToken, krtLessThanEqualsToken, krtGreaterThanEqualsToken, krtExclamationEqualsToken, krtPlusToken, krtMinusToken, krtAsteriskToken, krtSlashToken, krtPercentToken, krtExclamationToken, krtEqualsToken, krtWhileKeyword, krtOpenParenToken, krtCloseParenToken, krtCommaToken, krtSemicolonToken, krtOpenBraceToken, krtCloseBraceToken, krtGreaterThanToken, krtLessThanToken;
}

/*
 * Gramatica C Reducido
 */
grammar c_reducido
{
    Program := Deflist ;
    Deflist := A ;
    A := Def A | ;
    Def := Type identifier Defp;
    Defp := Vardef krtSemicolonToken | Fundef ;
    Fundef := krtOpenParenToken Paramlist krtCloseParenToken Fundefp ;
    Fundefp := krtSemicolonToken | krtOpenBraceToken Stmtlist krtCloseBraceToken ;
    Paramlist := Type identifier Paramlistcont | ;
    Paramlistcont := krtCommaToken Type identifier Paramlistcont | ;
    Vardef := Varinit Vardefcont ;
    Varinit := Varinitp ;
    Varinitp := krtEqualsToken Expr | ;
    Vardefcont := krtCommaToken identifier Varinit Vardefcont | ;
    Stmtlist := B ;
    B := Stmtall B | ;
    Stmtall := Flowcontrol | Stmt krtSemicolonToken ;
    Flowcontrol := Stmtif | Stmtwhile | Stmtfor ;
    Stmt := Type identifier Varinit Vardefcont | identifier Stmtp | Stmtbreak | Stmtreturn | Stmtempty ;
    Stmtp := Stmtassign | Stmtincr | Stmtdecr | Stmtfuncall ;
    Stmtassign := krtEqualsToken Expr ;
    Stmtincr := krtPlusPlusToken ;
    Stmtdecr := krtMinusminusToken ;
    Stmtbreak := krtBreakKeyword ;
    Stmtreturn := krtReturnKeyword Expr ;
    Stmtempty := ;
    Stmtfuncall := krtOpenParenToken Exprlist krtCloseParenToken ;
    Exprlist := Expr Exprlistcont | ;
    Exprlistcont := krtCommaToken Expr Exprlistcont | ;
    Stmtif := krtIfKeyword krtOpenParenToken Expr krtCloseParenToken krtOpenBraceToken Stmtlist krtCloseBraceToken ;
    Stmtwhile := krtWhileKeyword krtOpenParenToken Expr krtCloseParenToken krtOpenBraceToken Stmtlist krtCloseBraceToken ;
    Stmtfor := krtForKeyword krtOpenParenToken Stmt krtSemicolonToken Expr krtSemicolonToken Stmt krtCloseParenToken krtOpenBraceToken Stmtlist krtCloseBraceToken ;
    Expr := Expror ;
    Expror := Exprand Exprorp ;
    Exprorp := ;
    Exprand := Exprcomp E ;
    E := krtAmpersandAmpersandToken Exprcomp E | ;
    Exprcomp := Exprrel F ;
    F := Opcomp Exprrel F | ;
    Opcomp := krtEqualsEqualsToken | krtExclamationEqualsToken ;
    Exprrel := Expradd G ;
    G := Oprel Expradd G | ;
    Oprel := krtLessThanToken | krtLessThanEqualsToken | krtGreaterThanToken | krtGreaterThanEqualsToken ;
    Expradd := Exprmul H ;
    H := Opadd Exprmul H | ;
    Opadd := krtPlusToken | krtMinusToken ;
    Exprmul := Exprunary I ;
    I := Opmul Exprunary I | ;
    Opmul := krtAsteriskToken | krtSlashToken | krtPercentToken ;
    Exprunary := Opunary Exprunary | Exprprimary ;
    Opunary := krtPlusToken | krtMinusToken | krtExclamationToken ;
    Exprprimary := identifier Exprprimaryp | Lit | krtOpenParenToken Expr krtCloseParenToken ;
    Exprprimaryp := krtOpenParenToken Exprlist krtCloseParenToken | ;
    Lit := krtIntegerLiteral | krtDoubleLiteral ;
    Type := krtIntKeyword | krtDoubleKeyword ;
}